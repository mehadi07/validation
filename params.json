{"name":"Validation","tagline":"A class for functional error handling in Java 8","body":"# Installation\r\n\r\nAvailable from the Central Repository. In Maven style:\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>co.unruly</groupId>\r\n  <artifactId>validation</artifactId>\r\n  <version>1.0</version>\r\n</dependency>\r\n```\r\n\r\n## Create a validation\r\n```java\r\nValidation<String,String> success = Validation.success(\"woot\");\r\nValidation<String,String> failure = Validation.failure(\"awww\");\r\n```\r\nThe first type parameter T is the type of a successful value, the latter S the type of error(s)\r\n\r\n## Is this a success or a failure?\r\n```java\r\nboolean success = validation.isSuccess();\r\nboolean failure = validation.isFailure();\r\n```\r\n## Get the value\r\n```java\r\nT value = validation.get();\r\n```\r\n## Get the errors\r\n```java\r\nList<S> errors = validation.getErrors()\r\n```\r\n## Map or flatMap\r\n```java\r\n// Add one to contents\r\nValidation.success(2).map(i -> i + 1);\r\n\r\n// Add one to contents using flatMap\r\nValidation.success(2).flatMap(i -> Validation.success(i + 1));\r\n```\r\n\r\nMap and flatMap operate on the value of a **successful** Validation. They do not affect a failure Validation.\r\n\r\n## Filter\r\n```java\r\nValidation.success(2).filter(i -> i > 1);\r\n```\r\nFiltering a success with a non-truthy predicate will turn it into a failure with empty errors.\r\nIt does not affect a failure.\r\n## Catch exceptions\r\n```java\r\nValidation.tryTo(() -> /* do something that may throw */)\r\n```\r\nIf an exception is thrown, tryTo will return a failure validation with the exception in the errors.\r\n\r\n## Map, flatMap or filter with potentially exception throwing functions\r\n```java\r\nvalidation.tryMap(...)\r\nvalidation.tryFlatMap(...)\r\nvalidation.tryFilter(...)\r\n```\r\nIf an exception is thrown, the Validation is a failure with the exception in the errors.\r\n\r\nThere are a couple of caveats here:\r\n\r\n* The type of the errors of the returned Validation is **Object**\r\n* If function *f* throws and function *g* catches then `map(f).map(g)` may not equal `.map(g compose f)`\r\n\r\n## Composition\r\n```java\r\nValidation.success(3).compose(Validation.success(4), (a, b) -> a * b);\r\n```\r\nTwo composed successes produce a success with the values combined using the provided function.\r\nOtherwise a failure is produced, including errors from each.\r\n\r\nThere are also some static methods for composing many Validations of type T for a few common types T\r\n(Integer, Long, Float, Double, Boolean, Collection, Map) with a sensible default composition function:\r\n```java\r\nValidation.compose(() -> Validation.success(3L), () -> Validation.success(4L));\r\n```\r\nThe use of lambda suppliers here is [a pattern][0] for working around Java's type erasure.\r\n\r\n[0]: http://benjiweber.co.uk/blog/2015/02/20/work-around-java-same-erasure-errors-with-lambdas/ 'Work around Java “same erasure” errors with Lambdas'\r\n\r\n## Inspiration\r\n\r\nFrom Scala:\r\n\r\n* [scala.util.Either](http://www.scala-lang.org/api/2.11.5/index.html#scala.util.Either)\r\n* [scala.util.Try](http://www.scala-lang.org/api/2.11.5/index.html#scala.util.Try)\r\n\r\nFrom Scalaz:\r\n\r\n* [scalaz.\\/](http://docs.typelevel.org/api/scalaz/nightly/index.html#scalaz.$bslash$div)\r\n* [scalaz.Validation](http://docs.typelevel.org/api/scalaz/nightly/index.html#scalaz.Validation)\r\n\r\nFrom Rust:\r\n\r\n* [std::result::Result](https://doc.rust-lang.org/std/result/)\r\n\r\nThere are many similar types in other functional languages.","google":"UA-54623334-2","note":"Don't delete this file! It's used internally to help with page regeneration."}