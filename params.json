{"name":"Validation","tagline":"A class for functional error handling in Java 8","body":"# Installation\r\n\r\nAvailable from the Central Repository. In Maven style:\r\n\r\n        <dependency>\r\n            <groupId>co.unruly</groupId>\r\n            <artifactId>validation</artifactId>\r\n            <version>1.0</version>\r\n        </dependency>\r\n\r\n## Create a validation\r\n\r\n    Validation<String,String> success = Validation.success(\"woot\");\r\n    Validation<String,String> failure = Validation.failure(\"awww\");\r\n\r\nThe first type parameter T is the type of a successful value, the latter S the type of error(s)\r\n\r\n## Is this a success or a failure?\r\n\r\n    boolean success = validation.isSuccess()\r\n    boolean failure = validation.isFailure()\r\n\r\n## Get the value\r\n\r\n    T value = validation.get()\r\n\r\n## Get the errors\r\n\r\n    List<S> errors = validation.getErrors()\r\n\r\n## Map or flatMap\r\n\r\n    Validation.success(2).map(i -> i + 1);\r\n    Validation.success(2).flatMap(i -> Validation.success(i + 1));\r\n\r\nMap and flatMap operate on the value of a successful Validation. They do not affect a failure Validation.\r\n\r\n\r\n## Filter\r\n\r\n    Validation.success(2).filter(i -> i > 1);\r\n\r\nFiltering a success can turn it into a failure with empty errors. It does not affect a failure.\r\n\r\n## Catch exceptions\r\n\r\n    Validation.tryTo(() -> /* do something that may throw */)\r\n\r\nIf an exception is thrown tryTo will return a failure validation with the exception in the errors.\r\n\r\n## Map, flatMap or filter with potentially exception throwing functions\r\n\r\n    validation.tryMap(...)\r\n    validation.tryFlatMap(...)\r\n    validation.tryFilter(...)\r\n\r\nIf there is an exception the Validation is a failure with the exception in the errors.\r\n\r\nThere are a couple of caveats here:\r\n\r\n* The type of the errors of the returned Validation is Object\r\n* If function f throws and function g catches then map(f).map(g) may not equal map(g compose f)\r\n\r\n## Composition\r\n\r\n    Validation.success(3).compose(Validation.success(4), (a, b) -> a * b);\r\n\r\nTwo composed successes produce a success with the values combined using the provided function. Otherwise a failure is\r\nproduced, including errors from each.\r\n\r\nThere are also some static methods for composing many Validations of type T for a few common types T\r\n(Integer, Long, Float, Double, Boolean, Collection, Map) with a sensible default composition function:\r\n\r\n    Validation.compose(() -> Validation.success(3L), () -> Validation.success(4L));\r\n\r\nThe use of lambda suppliers here is [a pattern][0] for working around Java's type erasure.\r\n\r\n[0]: http://benjiweber.co.uk/blog/2015/02/20/work-around-java-same-erasure-errors-with-lambdas/ 'Work around Java “same erasure” errors with Lambdas'\r\n\r\n## Inspiration\r\n\r\nFrom Scala:\r\n\r\n* scala.util.Either\r\n* scala.util.Try\r\n\r\nFrom Scalaz:\r\n\r\n* scalaz.\\/\r\n* scalaz.Validation\r\n\r\nFrom Rust:\r\n\r\n* std::result::Result\r\n\r\nThere are many similar types in other functional languages.","google":"UA-54623334-2","note":"Don't delete this file! It's used internally to help with page regeneration."}